---
title: "Hands-on Exercise 1"
editor: visual
---

## 1  Geospatial Data Wrangling with R

## Overview

In this hands-on exercise, you will learn how to handle geospatial data in R by using **sf** package.

By the end of this hands-on exercise, you should acquire the following competencies:

-   importing geospatial data by using appropriate functions of **sf** package,

-   importing aspatial data by using appropriate function of **readr** package,

-   exploring the content of simple feature data frame by using appropriate **Base R** and **sf** functions,

-   assigning or transforming coordinate systems by using using appropriate *sf* functions,

-   converting an aspatial data into a sf data frame by using appropriate function of **sf** package,

-   performing geoprocessing tasks by using appropriate functions of **sf** package,

-   performing data wrangling tasks by using appropriate functions of **dplyr** package and

-   performing Exploratory Data Analysis (EDA) by using appropriate functions from **ggplot2** package.

## Getting Started

In this hands-on exercise, the following packages will be used:

-   **readr** for importing csv data,

-   **readxl** for importing Excel worksheet,

-   **tidyr** for manipulating data,

-   **dplyr** for transforming data, and

-   **ggplot2** for visualising data

```{r}
packages = c('sf', 'tidyverse')

for (p in packages){

if(!require(p, character.only = T)){

install.packages(p)

}

library(p,character.only = T)

}
```

### Importing polygon feature data in shapefile format

```{r}
mpsz = st_read(dsn = "data/geospatial",

layer = "MP14_SUBZONE_WEB_PL")
```

### Importing polyline feature data in shapefile form

```{r}
cyclingpath = st_read(dsn = "data/geospatial",

layer = "CyclingPath")
```

### Importing GIS data in kml format

```{r}
preschool = st_read("data/geospatial/pre-schools-location-kml.kml")
```

### Checking the Content of A Simple Feature Data Frame

#### Working with *st_geometry()*

```{r}
st_geometry(mpsz)
```

#### 

Working with glimpse()

```{r}
glimpse(mpsz)
```

#### Working with *head()*

```{r}
head(mpsz, n=5)
```

### 

Plotting the Geospatial Data

```{r}
plot(mpsz)
```

```{r}
plot(st_geometry(mpsz))
```

```{r}
plot(mpsz["PLN_AREA_N"])
```

### Working with Projection

#### Assigning EPSG code to a simple feature data frame

```{r}
st_crs(mpsz)
```

```{r}
mpsz3414 <- st_set_crs(mpsz, 3414)
```

```{r}
st_crs(mpsz3414)
```

#### Transforming the projection of preschool from wgs84 to svy21.

```{r}
preschool3414 <- st_transform(preschool,

crs = 3414)
```

```{r}
st_geometry(preschool3414)
```

### Importing and Converting An Aspatial Data

#### Importing the aspatial data

```{r}
listings <- read_csv("data/aspatial/listings.csv")
```

```{r}
list(listings)
```

#### Creating a simple feature data frame from an aspatial data frame

```{r}
listings_sf <- st_as_sf(listings,

coords = c("longitude", "latitude"),

crs=4326) %>%

st_transform(crs = 3414)
```

```{r}
glimpse(listings_sf)
```

### Geoprocessing with sf package

#### Buffering

```{r}
buffer_cycling <- st_buffer(cyclingpath,

dist=5, nQuadSegs = 30)
```

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
```

```{r}
sum(buffer_cycling$AREA)
```

#### Point-in-polygon count

```{r}
mpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))
```

```{r}
summary(mpsz3414$`PreSch Count`)
```

```{r}
top_n(mpsz3414, 1, `PreSch Count`)
```

```{r}
mpsz3414$Area <- mpsz3414 %>%

st_area()
```

```{r}
mpsz3414 <- mpsz3414 %>%

mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
```

### Explorotary Data Analysis (EDA)

```{r}
hist(mpsz3414$`PreSch Density`)
```

#### histogram

```{r}
ggplot(data=mpsz3414,

aes(x= as.numeric(`PreSch Density`)))+

geom_histogram(bins=20,

color="black",

fill="light blue") +

labs(title = "Are pre-school even distributed in Singapore?",

subtitle= "There are many planning sub-zones with a single pre-school, on the other hand, \nthere are two planning sub-zones with at least 20 pre-schools",

x = "Pre-school density (per km sq)",

y = "Frequency")
```

#### scatter plot

```{r}
ggplot(data=mpsz3414,

aes(x= as.numeric(`PreSch Density`), y= as.numeric(`PreSch Count`)))+

geom_point() +

labs(title = "Are pre-school even distributed in Singapore?",

subtitle= "There are many planning sub-zones with a single pre-school, on the other hand, \nthere are two planning sub-zones with at least 20 pre-schools",

x = "Pre-school density (per km sq)",

y = "Pre-school Count")
```

## 2  Choropleth Mapping with R

## Overview

Choropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. For example, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary.

In this chapter, you will learn how to plot functional and truthful choropleth maps by using an R package called \*\*tmap\*\* package.

## Getting Started

In this hands-on exercise, the key R package use is [**tmap**](https://cran.r-project.org/web/packages/tmap/) package in R. Beside **tmap** package, four other R packages will be used. They are:

-   [**readr**](https://readr.tidyverse.org/) for importing delimited text file,

-   [**tidyr**](https://tidyr.tidyverse.org/) for tidying data,

-   [**dplyr**](https://dplyr.tidyverse.org/) for wrangling data and

-   [**sf**](https://cran.r-project.org/web/packages/sf/) for handling geospatial data.

Among the four packages, **readr**, **tidyr** and **dplyr** are part of **tidyverse** package.

The code chunk below will be used to install and load these packages in RStudio.

```{r}
pacman::p_load(sf, tmap, tidyverse)
```

### Importing Data into R

```{r}
mpsz <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

```{r}
mpsz
```

### Importing Attribute Data into R

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")
```

### 

Data Preparation

#### Data wrangling

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

#### Joining the attribute data and geospatial data

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = funs(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

```{r}
mpsz_pop2020 <- left_join(mpsz, popdata2020,
                          by = c("SUBZONE_N" = "SZ"))
```

```{r}
write_rds(mpsz_pop2020, "data/rds/mpszpop2020.rds")
```

## Choropleth Mapping Geospatial Data Using *tmap*

### Plotting a choropleth map quickly by using *qtm()*

```{r}
tmap_mode("plot")
qtm(mpsz_pop2020, 
    fill = "DEPENDENCY")
```

### Creating a choropleth map by using *tmap*'s elements

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "Dependency ratio") +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

#### Drawing a base map

```{r}
tm_shape(mpsz_pop2020) +
  tm_polygons()
```

#### Drawing a choropleth map using *tm_polygons()*

```{r}
tm_shape(mpsz_pop2020)+
  tm_polygons("DEPENDENCY")
```

#### Drawing a choropleth map using *tm_fill()* and \*tm_border()\*\*

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY")
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY") +
  tm_borders(lwd = 0.1,  alpha = 1)
```

### Data classification methods of **tmap**

#### 

Plotting choropleth maps with built-in classification methods

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "jenks") +
  tm_borders(alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5)
```

#### Plotting choropleth map with custome break

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +
  tm_borders(alpha = 0.5)
```

### Colour Scheme

#### Using ColourBrewer palette

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "Blues") +
  tm_borders(alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens") +
  tm_borders(alpha = 0.5)
```

### Map Layouts

#### Map Legend

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "jenks", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```

#### Map style

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "-Greens") +
  tm_borders(alpha = 0.5) +
  tmap_style("classic")
```

#### Cartographic Furniture

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "No. of persons") +
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

```{r}
tmap_style("white")
```

### Drawing Small Multiple Choropleth Maps

#### By assigning multiple values to at least one of the aesthetic arguments

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill(c("YOUNG", "AGED"),
          style = "equal", 
          palette = "Blues") +
  tm_layout(legend.position = c("right", "bottom")) +
  tm_borders(alpha = 0.5) +
  tmap_style("white")
```

```{r}
tm_shape(mpsz_pop2020)+ 
  tm_polygons(c("DEPENDENCY","AGED"),
          style = c("equal", "quantile"), 
          palette = list("Blues","Greens")) +
  tm_layout(legend.position = c("right", "bottom"))
```

#### By defining a group-by variable in *tm_facets()*

```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          thres.poly = 0) + 
  tm_facets(by="REGION_N", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = FALSE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(alpha = 0.5)
```

#### By creating multiple stand-alone maps with *tmap_arrange()*

```{r}
youngmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("YOUNG", 
              style = "quantile", 
              palette = "Blues")

agedmap <- tm_shape(mpsz_pop2020)+ 
  tm_polygons("AGED", 
              style = "quantile", 
              palette = "Blues")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

### Mappping Spatial Object Meeting a Selection Criterion

```{r}
tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION", ])+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```
